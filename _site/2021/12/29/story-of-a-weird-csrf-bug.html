<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Story of a weird CSRF bug | sudi’s blog</title>
<meta name="generator" content="Jekyll v4.3.4" />
<meta property="og:title" content="Story of a weird CSRF bug" />
<meta name="author" content="sudi" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Heyyy Everyoneeee, A couple of months ago I found an upload endpoint which was vulnerable to csrf ,but when I started with creating the poc for it . I realized that it’s not going to be that easy as it looks. It was a Hackerone program, I asked them for disclosure permission but didn’t get any response, so I will be referring to the target as redacted.com Some details about the application, it was a bidding site where users were required to upload verification documents like (driving licence, passport, etc) to access the bidding section of the site. Looking more into this in the verification document upload endpoint, I noticed that it can be submitted only once, which means once you have uploaded the document you can’t make any changes to it afterwards . It is then manually verified by the staff. This was request made when a user uploads a verification document: This rings a bell right? There is no csrf tokenin this request, it means it might be vulnerable to csrf. I quickly created a csrf poc for it using the fetch method. https://medium.com/media/c29d04e6be36d0fae49a1e68d01b83de/href When I opened this html file in my browser , the response of the request was 403 forbidden. Later I realized it’s because of the Origin check . In the request screenshot you can see the Origin header value is set to https://www.redacted.com, suppose if my csrf poc url was hosted on the domain attacker.com. Eg. https://www.attacker.com/csrf.html then the Origin header value would have been https://www.attacker.com when the fetch request was made. As https://www.attacker.com doesn’t matches with https://www.redacted.com ,the Origin check failed and that’s why the server returned a 403 forbidden error. Then I tried some variations like redacted.commxyz, redacted.com.xyz ,xyz.redacted.com in the Origin header, but none of them worked. Sometimes the developer makes some mistake in the regex, like they forgot to escape the dot character ,etc . In those cases it can be bypassed by using such variations. Then I completely removed the Origin header from the request and forward the request and noticed that it worked 200 ok response, the file was successfully uploaded. If there is no Origin header in the request the application doesn’t validates it, this is similar to the scenario when there is a Referer check in place so you used the meta tag with the content attribute set to no-referrer So I started searching if there’s any way which would allow me to make a request without the Origin header being sent in the request. I found this tweet Mr_7h3xc4 on Twitter: &quot;1. Base64 encode your csrf form2. Use data uri:data:text/html;base64, 3 . set this as src attribute for iframe on your server.4. Visit this link. Request will be sent without referer header. / Twitter&quot; 1. Base64 encode your csrf form2. Use data uri:data:text/html;base64, 3 . set this as src attribute for iframe on your server.4. Visit this link. Request will be sent without referer header. When I tried to follow this, it worked. The request was sent without the Origin header. But it was only working when I used the Form method inside an iframe with data protocol, the Origin header would always be sent in case of fetch and other similar related methods. We overcame one problem which was the Origin header , now there was one more to deal with. As we are stuck with the Form method, we can’t actually make a csrf poc interaction-less . If you take a look at the vulnerable request again: https://medium.com/media/17c9dd7085bc4edf6fb3a806c2de54b1/href Look at the line no 12, there is a filename parameter then after that we have the image data. The problem is that we can’t actually include the filename parameter and the image data on our own in the csrf poc. Because they are included only when file upload input is used. You can read this writeup for more information on this: Here it is, the file upload CSRF The current poc would be similar to this: As you can see in this gif, to exploit this csrf vulnerability we have to tell the victim to click on the upload button, and then choose a file from their system. Due to the required user interaction this makes it so unrealistic that the victim is going to upload a file as we told them to do so. At this moment, I remembered about watching a video by Liveoverflow where he was talking about the bugs found in Google Cloud Platform (GCP) during the $100k Hacking Prize competition. Make sure to watch this video completely before moving on, as Liveoverflow has explained it very well here: https://medium.com/media/19aeb337af1564ac4a7b63891024bf71/href One of the bugs submitted during this event was: [GCP] The File uploading CSRF in Google Cloud Shell Editor In this blog, the researcher @obmihail along with the csrf bug details ,has also shared details regarding a bug found in multipart requests parsing which allowed him to upload any files with his own content, which isn’t possible with the html form. Upon submitting the above form, the below request body will be sent: -----------------------------37419614939920406503637463242Content-Disposition: form-data; name=&quot;target&quot; file:///home/userhome/folder-----------------------------37419614939920406503637463242Content-Disposition: form-data; name=&quot;upload; filename=the_filename; x&quot; the content of file-----------------------------37419614939920406503637463242-- Using this multipart requests parsing bug , I could easily overcome the problem which I stated previously as I have now full control over the file contents: &gt;To exploit this csrf vulnerability we have to tell the victim to click on the upload button, and then choose a file from their system. I can now perform the csrf attack without any user interaction. Here is the final CSRF POC: https://medium.com/media/bb12ecba357427a75f5c12bb6a3a5408/href Focusing more on the name attribute: name=’\”;name=file;filename=d0B5jW1O_400x400.png;x’ , this trick allows me to upload any fake document without depending on the victim to upload any file , an image file gets upload automatically without any user interaction I submitted the report after verifying that the final poc actually worked and it was marked as duplicate :( I was invited to that report so I looked into it and found that someone had already reported this issue but he wasn’t able to provide a csrf poc without user interaction, also to overcome the Origin validation he demonstrated a poc which only works in a very lower version of Mozilla Firefox along with that it required the victim to upload a document for the poc to work. His report was closed as Informative as it required too much of user interaction. But my poc didn’t require any user interaction and also worked in the latest version of Firefox. I explained to the triager how my report is different from the Original report During that time Firefox 84.0.2 was the latest version. The triager then forwarded the report details to the team The team acknowledged the issue and found that it is indeed different from the duplicate report, this report was triaged and rewarded as a Medium Severity bug which would allow me to submit fake verification documents on behalf of the user. As the verification documents could only be submitted once , due to the fake documents the victim’s account will not get verified. He would have to create a new one. The attack surface was only limited to Firefox users and newly created acc which haven’t submitted any verification documents that&#39;s why the severity was lowered to Medium. I learned a lot while creating a poc so this was a win-win situation for me . I will be publishing another writeup at the end of this year so stay tuned :) Sya Everyoneeee &lt;hr&gt;&lt;p&gt;Story of a weird CSRF bug was originally published in InfoSec Write-ups on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;" />
<meta property="og:description" content="Heyyy Everyoneeee, A couple of months ago I found an upload endpoint which was vulnerable to csrf ,but when I started with creating the poc for it . I realized that it’s not going to be that easy as it looks. It was a Hackerone program, I asked them for disclosure permission but didn’t get any response, so I will be referring to the target as redacted.com Some details about the application, it was a bidding site where users were required to upload verification documents like (driving licence, passport, etc) to access the bidding section of the site. Looking more into this in the verification document upload endpoint, I noticed that it can be submitted only once, which means once you have uploaded the document you can’t make any changes to it afterwards . It is then manually verified by the staff. This was request made when a user uploads a verification document: This rings a bell right? There is no csrf tokenin this request, it means it might be vulnerable to csrf. I quickly created a csrf poc for it using the fetch method. https://medium.com/media/c29d04e6be36d0fae49a1e68d01b83de/href When I opened this html file in my browser , the response of the request was 403 forbidden. Later I realized it’s because of the Origin check . In the request screenshot you can see the Origin header value is set to https://www.redacted.com, suppose if my csrf poc url was hosted on the domain attacker.com. Eg. https://www.attacker.com/csrf.html then the Origin header value would have been https://www.attacker.com when the fetch request was made. As https://www.attacker.com doesn’t matches with https://www.redacted.com ,the Origin check failed and that’s why the server returned a 403 forbidden error. Then I tried some variations like redacted.commxyz, redacted.com.xyz ,xyz.redacted.com in the Origin header, but none of them worked. Sometimes the developer makes some mistake in the regex, like they forgot to escape the dot character ,etc . In those cases it can be bypassed by using such variations. Then I completely removed the Origin header from the request and forward the request and noticed that it worked 200 ok response, the file was successfully uploaded. If there is no Origin header in the request the application doesn’t validates it, this is similar to the scenario when there is a Referer check in place so you used the meta tag with the content attribute set to no-referrer So I started searching if there’s any way which would allow me to make a request without the Origin header being sent in the request. I found this tweet Mr_7h3xc4 on Twitter: &quot;1. Base64 encode your csrf form2. Use data uri:data:text/html;base64, 3 . set this as src attribute for iframe on your server.4. Visit this link. Request will be sent without referer header. / Twitter&quot; 1. Base64 encode your csrf form2. Use data uri:data:text/html;base64, 3 . set this as src attribute for iframe on your server.4. Visit this link. Request will be sent without referer header. When I tried to follow this, it worked. The request was sent without the Origin header. But it was only working when I used the Form method inside an iframe with data protocol, the Origin header would always be sent in case of fetch and other similar related methods. We overcame one problem which was the Origin header , now there was one more to deal with. As we are stuck with the Form method, we can’t actually make a csrf poc interaction-less . If you take a look at the vulnerable request again: https://medium.com/media/17c9dd7085bc4edf6fb3a806c2de54b1/href Look at the line no 12, there is a filename parameter then after that we have the image data. The problem is that we can’t actually include the filename parameter and the image data on our own in the csrf poc. Because they are included only when file upload input is used. You can read this writeup for more information on this: Here it is, the file upload CSRF The current poc would be similar to this: As you can see in this gif, to exploit this csrf vulnerability we have to tell the victim to click on the upload button, and then choose a file from their system. Due to the required user interaction this makes it so unrealistic that the victim is going to upload a file as we told them to do so. At this moment, I remembered about watching a video by Liveoverflow where he was talking about the bugs found in Google Cloud Platform (GCP) during the $100k Hacking Prize competition. Make sure to watch this video completely before moving on, as Liveoverflow has explained it very well here: https://medium.com/media/19aeb337af1564ac4a7b63891024bf71/href One of the bugs submitted during this event was: [GCP] The File uploading CSRF in Google Cloud Shell Editor In this blog, the researcher @obmihail along with the csrf bug details ,has also shared details regarding a bug found in multipart requests parsing which allowed him to upload any files with his own content, which isn’t possible with the html form. Upon submitting the above form, the below request body will be sent: -----------------------------37419614939920406503637463242Content-Disposition: form-data; name=&quot;target&quot; file:///home/userhome/folder-----------------------------37419614939920406503637463242Content-Disposition: form-data; name=&quot;upload; filename=the_filename; x&quot; the content of file-----------------------------37419614939920406503637463242-- Using this multipart requests parsing bug , I could easily overcome the problem which I stated previously as I have now full control over the file contents: &gt;To exploit this csrf vulnerability we have to tell the victim to click on the upload button, and then choose a file from their system. I can now perform the csrf attack without any user interaction. Here is the final CSRF POC: https://medium.com/media/bb12ecba357427a75f5c12bb6a3a5408/href Focusing more on the name attribute: name=’\”;name=file;filename=d0B5jW1O_400x400.png;x’ , this trick allows me to upload any fake document without depending on the victim to upload any file , an image file gets upload automatically without any user interaction I submitted the report after verifying that the final poc actually worked and it was marked as duplicate :( I was invited to that report so I looked into it and found that someone had already reported this issue but he wasn’t able to provide a csrf poc without user interaction, also to overcome the Origin validation he demonstrated a poc which only works in a very lower version of Mozilla Firefox along with that it required the victim to upload a document for the poc to work. His report was closed as Informative as it required too much of user interaction. But my poc didn’t require any user interaction and also worked in the latest version of Firefox. I explained to the triager how my report is different from the Original report During that time Firefox 84.0.2 was the latest version. The triager then forwarded the report details to the team The team acknowledged the issue and found that it is indeed different from the duplicate report, this report was triaged and rewarded as a Medium Severity bug which would allow me to submit fake verification documents on behalf of the user. As the verification documents could only be submitted once , due to the fake documents the victim’s account will not get verified. He would have to create a new one. The attack surface was only limited to Firefox users and newly created acc which haven’t submitted any verification documents that&#39;s why the severity was lowered to Medium. I learned a lot while creating a poc so this was a win-win situation for me . I will be publishing another writeup at the end of this year so stay tuned :) Sya Everyoneeee &lt;hr&gt;&lt;p&gt;Story of a weird CSRF bug was originally published in InfoSec Write-ups on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;" />
<link rel="canonical" href="http://localhost:4000/2021/12/29/story-of-a-weird-csrf-bug.html" />
<meta property="og:url" content="http://localhost:4000/2021/12/29/story-of-a-weird-csrf-bug.html" />
<meta property="og:site_name" content="sudi’s blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-12-29T00:00:00+05:30" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Story of a weird CSRF bug" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"sudi"},"dateModified":"2021-12-29T00:00:00+05:30","datePublished":"2021-12-29T00:00:00+05:30","description":"Heyyy Everyoneeee, A couple of months ago I found an upload endpoint which was vulnerable to csrf ,but when I started with creating the poc for it . I realized that it’s not going to be that easy as it looks. It was a Hackerone program, I asked them for disclosure permission but didn’t get any response, so I will be referring to the target as redacted.com Some details about the application, it was a bidding site where users were required to upload verification documents like (driving licence, passport, etc) to access the bidding section of the site. Looking more into this in the verification document upload endpoint, I noticed that it can be submitted only once, which means once you have uploaded the document you can’t make any changes to it afterwards . It is then manually verified by the staff. This was request made when a user uploads a verification document: This rings a bell right? There is no csrf tokenin this request, it means it might be vulnerable to csrf. I quickly created a csrf poc for it using the fetch method. https://medium.com/media/c29d04e6be36d0fae49a1e68d01b83de/href When I opened this html file in my browser , the response of the request was 403 forbidden. Later I realized it’s because of the Origin check . In the request screenshot you can see the Origin header value is set to https://www.redacted.com, suppose if my csrf poc url was hosted on the domain attacker.com. Eg. https://www.attacker.com/csrf.html then the Origin header value would have been https://www.attacker.com when the fetch request was made. As https://www.attacker.com doesn’t matches with https://www.redacted.com ,the Origin check failed and that’s why the server returned a 403 forbidden error. Then I tried some variations like redacted.commxyz, redacted.com.xyz ,xyz.redacted.com in the Origin header, but none of them worked. Sometimes the developer makes some mistake in the regex, like they forgot to escape the dot character ,etc . In those cases it can be bypassed by using such variations. Then I completely removed the Origin header from the request and forward the request and noticed that it worked 200 ok response, the file was successfully uploaded. If there is no Origin header in the request the application doesn’t validates it, this is similar to the scenario when there is a Referer check in place so you used the meta tag with the content attribute set to no-referrer So I started searching if there’s any way which would allow me to make a request without the Origin header being sent in the request. I found this tweet Mr_7h3xc4 on Twitter: &quot;1. Base64 encode your csrf form2. Use data uri:data:text/html;base64, 3 . set this as src attribute for iframe on your server.4. Visit this link. Request will be sent without referer header. / Twitter&quot; 1. Base64 encode your csrf form2. Use data uri:data:text/html;base64, 3 . set this as src attribute for iframe on your server.4. Visit this link. Request will be sent without referer header. When I tried to follow this, it worked. The request was sent without the Origin header. But it was only working when I used the Form method inside an iframe with data protocol, the Origin header would always be sent in case of fetch and other similar related methods. We overcame one problem which was the Origin header , now there was one more to deal with. As we are stuck with the Form method, we can’t actually make a csrf poc interaction-less . If you take a look at the vulnerable request again: https://medium.com/media/17c9dd7085bc4edf6fb3a806c2de54b1/href Look at the line no 12, there is a filename parameter then after that we have the image data. The problem is that we can’t actually include the filename parameter and the image data on our own in the csrf poc. Because they are included only when file upload input is used. You can read this writeup for more information on this: Here it is, the file upload CSRF The current poc would be similar to this: As you can see in this gif, to exploit this csrf vulnerability we have to tell the victim to click on the upload button, and then choose a file from their system. Due to the required user interaction this makes it so unrealistic that the victim is going to upload a file as we told them to do so. At this moment, I remembered about watching a video by Liveoverflow where he was talking about the bugs found in Google Cloud Platform (GCP) during the $100k Hacking Prize competition. Make sure to watch this video completely before moving on, as Liveoverflow has explained it very well here: https://medium.com/media/19aeb337af1564ac4a7b63891024bf71/href One of the bugs submitted during this event was: [GCP] The File uploading CSRF in Google Cloud Shell Editor In this blog, the researcher @obmihail along with the csrf bug details ,has also shared details regarding a bug found in multipart requests parsing which allowed him to upload any files with his own content, which isn’t possible with the html form. Upon submitting the above form, the below request body will be sent: -----------------------------37419614939920406503637463242Content-Disposition: form-data; name=&quot;target&quot; file:///home/userhome/folder-----------------------------37419614939920406503637463242Content-Disposition: form-data; name=&quot;upload; filename=the_filename; x&quot; the content of file-----------------------------37419614939920406503637463242-- Using this multipart requests parsing bug , I could easily overcome the problem which I stated previously as I have now full control over the file contents: &gt;To exploit this csrf vulnerability we have to tell the victim to click on the upload button, and then choose a file from their system. I can now perform the csrf attack without any user interaction. Here is the final CSRF POC: https://medium.com/media/bb12ecba357427a75f5c12bb6a3a5408/href Focusing more on the name attribute: name=’\\”;name=file;filename=d0B5jW1O_400x400.png;x’ , this trick allows me to upload any fake document without depending on the victim to upload any file , an image file gets upload automatically without any user interaction I submitted the report after verifying that the final poc actually worked and it was marked as duplicate :( I was invited to that report so I looked into it and found that someone had already reported this issue but he wasn’t able to provide a csrf poc without user interaction, also to overcome the Origin validation he demonstrated a poc which only works in a very lower version of Mozilla Firefox along with that it required the victim to upload a document for the poc to work. His report was closed as Informative as it required too much of user interaction. But my poc didn’t require any user interaction and also worked in the latest version of Firefox. I explained to the triager how my report is different from the Original report During that time Firefox 84.0.2 was the latest version. The triager then forwarded the report details to the team The team acknowledged the issue and found that it is indeed different from the duplicate report, this report was triaged and rewarded as a Medium Severity bug which would allow me to submit fake verification documents on behalf of the user. As the verification documents could only be submitted once , due to the fake documents the victim’s account will not get verified. He would have to create a new one. The attack surface was only limited to Firefox users and newly created acc which haven’t submitted any verification documents that&#39;s why the severity was lowered to Medium. I learned a lot while creating a poc so this was a win-win situation for me . I will be publishing another writeup at the end of this year so stay tuned :) Sya Everyoneeee &lt;hr&gt;&lt;p&gt;Story of a weird CSRF bug was originally published in InfoSec Write-ups on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;","headline":"Story of a weird CSRF bug","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2021/12/29/story-of-a-weird-csrf-bug.html"},"url":"http://localhost:4000/2021/12/29/story-of-a-weird-csrf-bug.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="sudi&apos;s blog" />
<script src="//cdn.jsdelivr.net/npm/@microlink/vanilla@latest/umd/microlink.min.js"></script>

<script>
  document.addEventListener('DOMContentLoaded', function (event) {
    microlink('.card-preview')
  })
</script>
  
</head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">sudi&#39;s blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Story of a weird CSRF bug</h1>
    <p class="post-meta"><time class="dt-published" datetime="2021-12-29T00:00:00+05:30" itemprop="datePublished">
        Dec 29, 2021
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>Heyyy Everyoneeee,</p><p>A couple of months ago I found an upload endpoint which was vulnerable to csrf ,but when I started with creating the poc for it . I realized that it’s not going to be that easy as it looks.</p><p>It was a <strong>Hackerone </strong>program, I asked them for disclosure permission but didn’t get any response, so I will be referring to the target as redacted.com</p><p>Some details about the application, it was a bidding site where users were required to upload verification documents like (<em>driving licence, passport, etc</em>) to access the bidding section of the site.</p><p>Looking more into this in the verification document upload endpoint, I noticed that it can be submitted only once, which means once you have uploaded the document you can’t make any changes to it afterwards . It is then manually verified by the staff.</p><p>This was request made when a user uploads a verification document:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/775/1*ADHKumNZiCbO8tkdco262w.png" /></figure><p>This rings a bell right?</p><p>There is no csrf tokenin this request, it means it might be vulnerable to csrf. I quickly created a csrf poc for it using the fetch method.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/c29d04e6be36d0fae49a1e68d01b83de/href">https://medium.com/media/c29d04e6be36d0fae49a1e68d01b83de/href</a></iframe><p>When I opened this html file in my browser , the response of the request was <strong><em>403 forbidden</em></strong>.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*2_of11-i-tsYB1lA4ALDTA.png" /></figure><p>Later I realized it’s because of the Origin check . In the request screenshot you can see the Origin header value is set to <a href="https://www.redacted.com,">https://www.redacted.com</a>, suppose if my csrf poc url was hosted on the domain attacker.com.</p><p>Eg. <a href="http://www.attacker.com/csrf.html">https://www.attacker.com/csrf.html</a> then the Origin header value would have been <a href="http://www.attacker.com/csrf.html">https://www.attacker.com</a> when the fetch request was made.</p><p>As <a href="http://www.attacker.com/csrf.html">https://www.attacker.com</a> doesn’t matches with <a href="https://www.redacted.com,">https://www.redacted.com</a> ,the <strong><em>Origin check</em></strong> failed and that’s why the server returned a <strong><em>403 forbidden error</em></strong>.</p><p>Then I tried some variations like redacted.commxyz, redacted.com.xyz ,xyz.redacted.com in the<em> Origin header</em>, but none of them worked. Sometimes the developer makes some mistake in the <em>regex</em>, like they forgot to escape the dot character ,etc . In those cases it can be bypassed by using such variations.</p><p>Then I completely removed the <em>Origin</em> header from the request and forward the request and noticed that it worked <strong><em>200 ok response</em></strong>, the file was successfully uploaded.</p><p>If there is no<em> Origin</em> header in the request the application doesn’t validates it, this is similar to the scenario when there is a <strong><em>Referer </em></strong>check in place so you used the meta tag with the content attribute set to no-referrer</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/559/1*HgoQu-YaAmgnGX6_Pcx6Xw.png" /></figure><p>So I started searching if there’s any way which would allow me to make a request without the <em>Origin </em>header being sent in the request. I found this tweet</p><h3>Mr_7h3xc4 on Twitter: &quot;1. Base64 encode your csrf form2. Use data uri:data:text/html;base64, 3 . set this as src attribute for iframe on your server.4. Visit this link. Request will be sent without referer header. / Twitter&quot;</h3><p>1. Base64 encode your csrf form2. Use data uri:data:text/html;base64, 3 . set this as src attribute for iframe on your server.4. Visit this link. Request will be sent without referer header.</p><p>When I tried to follow this, it worked. The request was sent without the <em>Origin </em>header. But it was only working when I used the <strong><em>Form </em>method</strong> inside an <em>iframe </em>with <em>data </em>protocol, the <em>Origin </em>header would always be sent in case of <em>fetch</em> and other similar related methods.</p><p>We overcame one problem which was the <em>Origin </em>header , now there was one more to deal with. As we are stuck with the <strong><em>Form </em></strong>method, we can’t actually make a csrf poc interaction-less .</p><p>If you take a look at the vulnerable request again:</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/17c9dd7085bc4edf6fb3a806c2de54b1/href">https://medium.com/media/17c9dd7085bc4edf6fb3a806c2de54b1/href</a></iframe><p>Look at the line no 12, there is a <em>filename </em>parameter then after that we have the <em>image </em>data. The problem is that we can’t actually include the <em>filename </em>parameter and the image data on our own in the csrf poc.</p><p>Because they are included only when <em>file upload input</em> is used. You can read this writeup for more information on this:</p><p><a href="http://aetherlab.net/2013/04/here-it-is-the-file-upload-csrf/">Here it is, the file upload CSRF</a></p><p>The current poc would be similar to this:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/783/1*VPD8mzAHRLlnLIeWdCB2Pw.png" /></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*zPgdlyfxGi2lLm2_gxXElA.gif" /></figure><p>As you can see in this gif, to exploit this <em>csrf vulnerability</em> we have to tell the victim to click on the upload button, and then choose a file from their system.</p><p>Due to the required user interaction this makes it so unrealistic that the victim is going to upload a file as we told them to do so.</p><p>At this moment, I remembered about watching a video by <strong>Liveoverflow </strong>where he was talking about the bugs found in Google Cloud Platform (GCP) during the $100k Hacking Prize competition.</p><p>Make sure to watch this video completely before moving on, as <strong>Liveoverflow </strong>has explained it very well here:</p><iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2FJ2icGMocQds%3Ffeature%3Doembed&amp;display_name=YouTube&amp;url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DJ2icGMocQds&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2FJ2icGMocQds%2Fhqdefault.jpg&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=youtube" width="854" height="480" frameborder="0" scrolling="no"><a href="https://medium.com/media/19aeb337af1564ac4a7b63891024bf71/href">https://medium.com/media/19aeb337af1564ac4a7b63891024bf71/href</a></iframe><p>One of the bugs submitted during this event was:</p><p><a href="https://obmiblog.blogspot.com/2019/12/gcp-5k-file-uploading-csrf.html?m=1">[GCP] The File uploading CSRF in Google Cloud Shell Editor</a></p><p>In this blog, the researcher <a href="https://bughunter.withgoogle.com/profile/40997bbc-945a-4eca-8408-eed302641c96">@obmihail</a> along with the <em>csrf bug</em> details ,has also shared details regarding a bug found in <em>multipart requests parsing</em> which allowed him to upload any files with his own content, which isn’t possible with the html form.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*WexuumPtdTYtxkqGVobKAQ.png" /></figure><p>Upon submitting the above form, the below request body will be sent:</p><pre>-----------------------------37419614939920406503637463242<br>Content-Disposition: form-data; name=&quot;target&quot;</pre><pre>file:///home/userhome/folder<br>-----------------------------37419614939920406503637463242<br>Content-Disposition: form-data; name=&quot;upload; filename=the_filename; x&quot;</pre><pre>the content of file<br>-----------------------------37419614939920406503637463242--</pre><p>Using this multipart requests parsing bug , I could easily overcome the problem which I stated previously as I have now full control over the file contents:</p><p>&gt;To exploit this csrf vulnerability we have to tell the victim to click on the upload button, and then choose a file from their system.</p><p>I can now perform the csrf attack without any user interaction.</p><p>Here is the final CSRF POC:</p><figure><img alt="https://gist.github.com/Sudistark/8fb9717dbce61fae1f6b8e2e74c81929" src="https://cdn-images-1.medium.com/max/1024/1*pJiZBR-P96MJfXqkuPP9qw.png" /></figure><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/bb12ecba357427a75f5c12bb6a3a5408/href">https://medium.com/media/bb12ecba357427a75f5c12bb6a3a5408/href</a></iframe><p>Focusing more on the name attribute: name=’\”;name=file;filename=d0B5jW1O_400x400.png;x’ , this trick allows me to upload any fake document without depending on the victim to upload any file , an image file gets upload automatically without any user interaction</p><p>I submitted the report after verifying that the final poc actually worked and it was marked as duplicate :(</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*9CfRC2OApMpxpFEryFwrQg.png" /></figure><p>I was invited to that report so I looked into it and found that someone had already reported this issue but he wasn’t able to provide a csrf poc without user interaction, also to overcome the Origin validation he demonstrated a poc which only works in a very lower version of Mozilla Firefox along with that it required the victim to upload a document for the poc to work. His report was closed as Informative as it required too much of user interaction.</p><p>But my <em>poc </em>didn’t require any user interaction and also worked in the latest version of Firefox. I explained to the <em>triager </em>how my report is different from the <em>Original report</em></p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*qGHMgHR399hDgG3JK1Rzuw.png" /></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*ehaKn2XbyDlFb-LscK__VA.png" /></figure><p>During that time <strong><em>Firefox 84.0.2</em></strong> was the latest version. The <em>triager </em>then forwarded the report details to the team</p><p>The team acknowledged the issue and found that it is indeed different from the duplicate report, this report was triaged and rewarded as a Medium Severity bug which would allow me to submit fake verification documents on behalf of the user.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/964/1*OZ3e2RFhOTxDel77A2JT7A.png" /></figure><p>As the verification documents could only be submitted once , due to the fake documents the victim’s account will not get verified. He would have to create a new one. The attack surface was only limited to Firefox users and newly created acc which haven’t submitted any verification documents that&#39;s why the severity was lowered to Medium.</p><p>I learned a lot while creating a poc so this was a win-win situation for me .</p><p>I will be publishing another writeup at the end of this year so stay tuned :)</p><p>Sya Everyoneeee</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=bde1129c106e" width="1" height="1" alt=""><hr><p><a href="https://infosecwriteups.com/story-of-a-weird-csrf-bug-bde1129c106e">Story of a weird CSRF bug</a> was originally published in <a href="https://infosecwriteups.com">InfoSec Write-ups</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>

  </div><a class="u-url" href="/2021/12/29/story-of-a-weird-csrf-bug.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="http://localhost:4000/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
        <ul class="contact-list">
          <li class="p-name">sudi</li>
          <li><a class="u-email" href="mailto:sudi[at]wearehackerone.com">sudi[at]wearehackerone.com</a></li>
        </ul>
      </div>
      <div class="footer-col">
        <p>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.
</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"></ul>
</div>

  </div>

</footer>
</body>

</html>
