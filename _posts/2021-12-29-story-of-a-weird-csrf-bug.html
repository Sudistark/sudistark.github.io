---
layout: post
title: Story of a weird CSRF bug
---

<p>Heyyy Everyoneeee,</p><p>A couple of months ago I found an upload endpoint which was vulnerable to csrf ,but when I started with creating the poc for it . I realized that it’s not going to be that easy as it looks.</p><p>It was a <strong>Hackerone </strong>program, I asked them for disclosure permission but didn’t get any response, so I will be referring to the target as redacted.com</p><p>Some details about the application, it was a bidding site where users were required to upload verification documents like (<em>driving licence, passport, etc</em>) to access the bidding section of the site.</p><p>Looking more into this in the verification document upload endpoint, I noticed that it can be submitted only once, which means once you have uploaded the document you can’t make any changes to it afterwards . It is then manually verified by the staff.</p><p>This was request made when a user uploads a verification document:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/775/1*ADHKumNZiCbO8tkdco262w.png" /></figure><p>This rings a bell right?</p><p>There is no csrf tokenin this request, it means it might be vulnerable to csrf. I quickly created a csrf poc for it using the fetch method.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/c29d04e6be36d0fae49a1e68d01b83de/href">https://medium.com/media/c29d04e6be36d0fae49a1e68d01b83de/href</a></iframe><p>When I opened this html file in my browser , the response of the request was <strong><em>403 forbidden</em></strong>.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*2_of11-i-tsYB1lA4ALDTA.png" /></figure><p>Later I realized it’s because of the Origin check . In the request screenshot you can see the Origin header value is set to <a href="https://www.redacted.com,">https://www.redacted.com</a>, suppose if my csrf poc url was hosted on the domain attacker.com.</p><p>Eg. <a href="http://www.attacker.com/csrf.html">https://www.attacker.com/csrf.html</a> then the Origin header value would have been <a href="http://www.attacker.com/csrf.html">https://www.attacker.com</a> when the fetch request was made.</p><p>As <a href="http://www.attacker.com/csrf.html">https://www.attacker.com</a> doesn’t matches with <a href="https://www.redacted.com,">https://www.redacted.com</a> ,the <strong><em>Origin check</em></strong> failed and that’s why the server returned a <strong><em>403 forbidden error</em></strong>.</p><p>Then I tried some variations like redacted.commxyz, redacted.com.xyz ,xyz.redacted.com in the<em> Origin header</em>, but none of them worked. Sometimes the developer makes some mistake in the <em>regex</em>, like they forgot to escape the dot character ,etc . In those cases it can be bypassed by using such variations.</p><p>Then I completely removed the <em>Origin</em> header from the request and forward the request and noticed that it worked <strong><em>200 ok response</em></strong>, the file was successfully uploaded.</p><p>If there is no<em> Origin</em> header in the request the application doesn’t validates it, this is similar to the scenario when there is a <strong><em>Referer </em></strong>check in place so you used the meta tag with the content attribute set to no-referrer</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/559/1*HgoQu-YaAmgnGX6_Pcx6Xw.png" /></figure><p>So I started searching if there’s any way which would allow me to make a request without the <em>Origin </em>header being sent in the request. I found this tweet</p><h3>Mr_7h3xc4 on Twitter: &quot;1. Base64 encode your csrf form2. Use data uri:data:text/html;base64, 3 . set this as src attribute for iframe on your server.4. Visit this link. Request will be sent without referer header. / Twitter&quot;</h3><p>1. Base64 encode your csrf form2. Use data uri:data:text/html;base64, 3 . set this as src attribute for iframe on your server.4. Visit this link. Request will be sent without referer header.</p><p>When I tried to follow this, it worked. The request was sent without the <em>Origin </em>header. But it was only working when I used the <strong><em>Form </em>method</strong> inside an <em>iframe </em>with <em>data </em>protocol, the <em>Origin </em>header would always be sent in case of <em>fetch</em> and other similar related methods.</p><p>We overcame one problem which was the <em>Origin </em>header , now there was one more to deal with. As we are stuck with the <strong><em>Form </em></strong>method, we can’t actually make a csrf poc interaction-less .</p><p>If you take a look at the vulnerable request again:</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/17c9dd7085bc4edf6fb3a806c2de54b1/href">https://medium.com/media/17c9dd7085bc4edf6fb3a806c2de54b1/href</a></iframe><p>Look at the line no 12, there is a <em>filename </em>parameter then after that we have the <em>image </em>data. The problem is that we can’t actually include the <em>filename </em>parameter and the image data on our own in the csrf poc.</p><p>Because they are included only when <em>file upload input</em> is used. You can read this writeup for more information on this:</p><p><a href="http://aetherlab.net/2013/04/here-it-is-the-file-upload-csrf/">Here it is, the file upload CSRF</a></p><p>The current poc would be similar to this:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/783/1*VPD8mzAHRLlnLIeWdCB2Pw.png" /></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*zPgdlyfxGi2lLm2_gxXElA.gif" /></figure><p>As you can see in this gif, to exploit this <em>csrf vulnerability</em> we have to tell the victim to click on the upload button, and then choose a file from their system.</p><p>Due to the required user interaction this makes it so unrealistic that the victim is going to upload a file as we told them to do so.</p><p>At this moment, I remembered about watching a video by <strong>Liveoverflow </strong>where he was talking about the bugs found in Google Cloud Platform (GCP) during the $100k Hacking Prize competition.</p><p>Make sure to watch this video completely before moving on, as <strong>Liveoverflow </strong>has explained it very well here:</p><iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2FJ2icGMocQds%3Ffeature%3Doembed&amp;display_name=YouTube&amp;url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DJ2icGMocQds&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2FJ2icGMocQds%2Fhqdefault.jpg&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=youtube" width="854" height="480" frameborder="0" scrolling="no"><a href="https://medium.com/media/19aeb337af1564ac4a7b63891024bf71/href">https://medium.com/media/19aeb337af1564ac4a7b63891024bf71/href</a></iframe><p>One of the bugs submitted during this event was:</p><p><a href="https://obmiblog.blogspot.com/2019/12/gcp-5k-file-uploading-csrf.html?m=1">[GCP] The File uploading CSRF in Google Cloud Shell Editor</a></p><p>In this blog, the researcher <a href="https://bughunter.withgoogle.com/profile/40997bbc-945a-4eca-8408-eed302641c96">@obmihail</a> along with the <em>csrf bug</em> details ,has also shared details regarding a bug found in <em>multipart requests parsing</em> which allowed him to upload any files with his own content, which isn’t possible with the html form.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*WexuumPtdTYtxkqGVobKAQ.png" /></figure><p>Upon submitting the above form, the below request body will be sent:</p><pre>-----------------------------37419614939920406503637463242<br>Content-Disposition: form-data; name=&quot;target&quot;</pre><pre>file:///home/userhome/folder<br>-----------------------------37419614939920406503637463242<br>Content-Disposition: form-data; name=&quot;upload; filename=the_filename; x&quot;</pre><pre>the content of file<br>-----------------------------37419614939920406503637463242--</pre><p>Using this multipart requests parsing bug , I could easily overcome the problem which I stated previously as I have now full control over the file contents:</p><p>&gt;To exploit this csrf vulnerability we have to tell the victim to click on the upload button, and then choose a file from their system.</p><p>I can now perform the csrf attack without any user interaction.</p><p>Here is the final CSRF POC:</p><figure><img alt="https://gist.github.com/Sudistark/8fb9717dbce61fae1f6b8e2e74c81929" src="https://cdn-images-1.medium.com/max/1024/1*pJiZBR-P96MJfXqkuPP9qw.png" /></figure><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/bb12ecba357427a75f5c12bb6a3a5408/href">https://medium.com/media/bb12ecba357427a75f5c12bb6a3a5408/href</a></iframe><p>Focusing more on the name attribute: name=’\”;name=file;filename=d0B5jW1O_400x400.png;x’ , this trick allows me to upload any fake document without depending on the victim to upload any file , an image file gets upload automatically without any user interaction</p><p>I submitted the report after verifying that the final poc actually worked and it was marked as duplicate :(</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*9CfRC2OApMpxpFEryFwrQg.png" /></figure><p>I was invited to that report so I looked into it and found that someone had already reported this issue but he wasn’t able to provide a csrf poc without user interaction, also to overcome the Origin validation he demonstrated a poc which only works in a very lower version of Mozilla Firefox along with that it required the victim to upload a document for the poc to work. His report was closed as Informative as it required too much of user interaction.</p><p>But my <em>poc </em>didn’t require any user interaction and also worked in the latest version of Firefox. I explained to the <em>triager </em>how my report is different from the <em>Original report</em></p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*qGHMgHR399hDgG3JK1Rzuw.png" /></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*ehaKn2XbyDlFb-LscK__VA.png" /></figure><p>During that time <strong><em>Firefox 84.0.2</em></strong> was the latest version. The <em>triager </em>then forwarded the report details to the team</p><p>The team acknowledged the issue and found that it is indeed different from the duplicate report, this report was triaged and rewarded as a Medium Severity bug which would allow me to submit fake verification documents on behalf of the user.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/964/1*OZ3e2RFhOTxDel77A2JT7A.png" /></figure><p>As the verification documents could only be submitted once , due to the fake documents the victim’s account will not get verified. He would have to create a new one. The attack surface was only limited to Firefox users and newly created acc which haven’t submitted any verification documents that&#39;s why the severity was lowered to Medium.</p><p>I learned a lot while creating a poc so this was a win-win situation for me .</p><p>I will be publishing another writeup at the end of this year so stay tuned :)</p><p>Sya Everyoneeee</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=bde1129c106e" width="1" height="1" alt=""><hr><p><a href="https://infosecwriteups.com/story-of-a-weird-csrf-bug-bde1129c106e">Story of a weird CSRF bug</a> was originally published in <a href="https://infosecwriteups.com">InfoSec Write-ups</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>
